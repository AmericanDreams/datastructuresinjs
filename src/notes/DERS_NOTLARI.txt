Project in github
https://github.com/AmericanDreams/datastructuresinjs

1. Ders 

- Time ve Space Complexity nedir
- O(1), O(logN), O(N), O(N`2) ve s.
- in Place 
- Abstract Data Type vs Data Structure


2. Ders

--- Static Array ---
PROS
- Çox sürətli işləyir və bir çox proqramlama dillərində built in data structure olaraq hazır gəlir.

CONS
- Arrayi yaradarkən ölçüsünü bilmək məcburiyyətindəyik. Vəs onradan artıra bilmərik.


Əməliyyatlar
add(item) - O(1)
getByIndex(index) -> O(1)

========================

--- List ---
---- ArrayList ve ya Dynamic Array ---
PROS
- Array-dən fərli olaraq başlanğıcda ölçünü bilmək mücburiyyətində deyilik və ölçüsü dinamik olaraq artır

CONS
- Xüsusi ilə silmə əməliyyatı çox ləng işləyir. Buna görə də əgər alqpritm bizdən listin içərisindən tez-tez
məlumat ların silməyə məcbur edirsə ArrayList ən yaxşı seçim olmaya bilər (Bax LinkedList).

- Amma silməkdən daha çox listin içindəki dəyərləri oxumaq əməliyyatı edəcəyiksə ArrayList dən istifadə yaxçı fikirdir.

Əməliyyatlar
addToEnd(item) - Amortized O(1)
getByIndex(index) -> O(1)
addToHead() => O(N)
removeFromHead() -> O(N)
removeFromEnd() -> O(1)
removeByIndex() -> O(N) in the worst case

https://en.wikipedia.org/wiki/Dynamic_array

===========================

--- LinkedList ---
--- Single LinkedList ---

PROS
- Xüsusi ilə ilk item-i silmə əməliyyatı çox sürətli işləyir.

CONS
- Əgər list in içərisindən tez-tez index ləri ilə məlumatları oxuyacaqıqsa LinkedList bu məsəslədə çox zəifdir. Çünki
Hər dəfə hesablıyaraq axtarılan index-dəki item-i tapmaqa çalışmalıdıdr.

- ArrayList ilə müqayisə də çox yaddaş tutur çünki burada hər node özündən sonrakı nodun referensini 
özündən saxlamalıdıdr.

Əməliyyatlar
add(item) - O(N)
getByIndex(index) -> O(N)
addToHead() => O(1)
removeFromHead() -> O(1)
removeFromEnd() -> O(N)
removeByIndex() -> O(N) in the worst case

https://en.wikipedia.org/wiki/Linked_list

3. Ders

--- Double Linked List ---
PROS
- Xüsusi ilə silmə əməliyyatları çox sürətli həyata keçir. Buna görə də əgər algorithm bizdən tez-tez listin içərisindən
silmə tələb edirsə seçiləcək ən yaxşı yoxllardan biri linkedlistdir.

CONS
- İndexi ilə item i tapmaq ləng işləyir. Ən yaxşı implementasiya ilə bu zamanı O(N/2) salmaq mümkündür.
- ArrayList ilə müqayisədə çox böyük yaddaş zəbt edir çenki burada hər nodə həm pzündən sonrakı həm də 
əvvəlki nodeun referebsini özündə saxlayır.

Əməliyyatlar
add(item) - O(1)
getByIndex(index) -> O(N/2)
addToHead() => O(1)
removeFromHead() -> O(1)
removeFromEnd() -> O(1)
removeByIndex() -> O(N/2) in the worst case

--- ArrayList vs LinkedList ---
- Bir çox algorithm lərdə bu iki DS dən birini seçməli oluruq. Diqqət etməli olduqum şey algərithm in bizdən
nə tələb etdiyi olmalıdıdr. Əgər listin içərisinən çoxlu sayda silmə əməliyyatı edəcəyiksə LinkedList daya yaxşı alternativdir.
Yox əgər bir o qədər də silmə əməliyyatına ehtiyacımız yoxdur və daha çox listin içərisindəki dəyərləri onların index
ləri ilə sorğulayacaqıqsa ArrayList ən yaxşı alternativ ola bilər.


--- Stack ---

Stack ADT elementleri LIFO strategiyasi ile ozunde saxlayan linear data tipdir.

PROS
- Alqorithmlərin həllində olduqca cox işə yarayır. Ümmumiyyətlə Stack çox məşhur bir ADT dir. Məsələn Stack memory
arxa tərəfdə Stack ADT ilə implement olunmuşdur. 
- LIFO Strategiya ilə işləyir. Yəni ki , hansı item axırıncı daxil olarsa həmin item ilk silinən olacaq.

CONS
- Yalnız LİFO strategiya ilə işlədiyinə görə həmişə ən yaxşı seçim olmaya bilər

Əməliyyatlar
push(item) -> Stackin əvvəlinə yeni item əlavə edir
peek() -> İlk itemi geri qaytarır
pop(item) -> İlk item i geri qaytarır və onu stack dən silir

https://en.wikipedia.org/wiki/Stack_(abstract_data_type)


Stack implementasiyası ArrayList ilə
push(item) -> Amortized O(1)
peek() -> O(1)
pop(item) -> O(1)

Stack implementasiyası LinkedList ilə
push(item) -> O(1)
peek() -> O(1)
pop(item) -> O(1)


--- Queue ---

Queue (Növbə) ADT elementleri özündə FİFO strategiyası ilə saxlayan linear data tipdir.

PROS
- FİFO strategiysl ilə işləyir. Yıni ilk hansı element daxil edilibsə ilk silinən də o olacaq.
- Məşhur ADT dir. Məsələn Prosessorlar onları gələn taskları arxa tərəfdə Queue ADT ilə sıralayırlar. Hansı task
ilk daxil edlibsə deməli o birinci həll olunmalıdır.

CONS
- Yalnız FİFO strategiya ilə işlədiyinə görə həmişə ən yaxşı seçim olmaya bilər

Əməliyyatlar
enQueue(item) -> Queue-nin sonuna yeni element daxil edir
deQueue() -> Queue nin əvvəlindəki elementi silir
peek() -> Queue nin əvvəlindəki elementi geri qaytarır amma SİLMİR


https://en.wikipedia.org/wiki/Queue_(abstract_data_type)

Queue implementasıyası SingleLinkedList ilə
enQueue(item) -> O(1)
deQueue() -> O(1)
peek() -> O(1)


4. Ders

-- Associative Arrays --

Associative array, map, symbol table, yaxud dictionary ADT Açar (key) və Dəyər (value) cütlüklərini özündə saxlayır. Önəmli
detallardan biri isə eyni açar (key) in yalnız bir dəfə iştirak edəcəyidir.

-- Hash Table --
Hash table Associative Arrays ADT - ni implement eden DS lərdən biridir. Hsh Table arxa tərəfdə bir array saxlayır vəverilən 
key və value nun key-indən hash codunu hesablıyaraq həmin cütlüyün arrayın hansı indeksində yerləşdiriləcəyini müəyyənləş-
dirir. Sonra yenidən həmin key vasitəsi ilə value sorğulanan zaman Hash Table yenidən göndərilən keyə əsasən onun hash - ını
hesablayır və bu key ilə daxil olunmuş key-value cütlüyü əgər varsa arxadakı arrayın hansı indeksində ola biləcəyini müəyyənləş-
dirir.


Hash funksiyası elə bir funcsiyasıdır ki, ona daxil olan ixtiyari sonsuz sayda dəyəri xüsusi dəyər aralıqı ilə əvəz edir. Bu funnk-
siyadan geri qayıdan dəyərə hash, hash code, hash value və ya digest deyilir.

İnput sonsuz sayda => hash() => Output sonlu sayda

Ancaq, Hash Table nin arxa tərəfdə cütlükləri saxladıqı array in ölcüsünün bir limiti olduquna görə bir nöqtədən sonra
Array tmamilə dolacaqdır və yeni cütlük daxil etməyə yer qalmayacaqdır. Buna collission (Kəsişmə, üst-üstə minmə) halı deyilir
və bu problemin üstəsindən gəlmək üçün mıxtəlif strategiyalar var.

-- Chaining (Zincirləmə) --

Burada arxadakı arrayın hər slot (qutu və ya index) ində yalnız bir dəyər saxlamaq əvəzinə burada linked list saxlaya bilərik.
Və bununla da kəsişmə problemi həll olar. Sadecə problem burdadır ki , bu halda əgər hash() funksiyamız bir çox key üçün
eyni code geri göndərərsə bunlar hamısı bir slotda single listin node ləri olaraq tutulacaq və sonradan həmin valuelərin
içindən axtardımız dəyəri tapmaq uzun zaman başa gələcəkdir. Çünki biz Həmin slotdakı linkedlist in nodlarını bir-bir axtarmalı
və axtardıqmız key in orda olub olmaıdıqnı müəyyənləşdirməli olacaqıq. Amma , uyğulanması olduqca asandır.

Əməliyyatlar
put(key, value) => The best O(1), The worst O(N)
get(key) => The best O(1), The worst O(N)
set(key, value) => The best O(1), The worst O(N)
delete(key) => The best O(1), The worst O(N)

-- Probbing (yoxlama, deneme-yanılma) --

Bu da collission problemi həll etmək üçün istifadə olunan başqa bir strategiyadır. Burada isə əgər key ə uyğun hash ı hesabla-
dıqdan sonra görsək ki, index doludur digər indeksə yerləşdirik. Probbing in də fərqli növləri var. Məsələn linear probbing.
Burada əgər index doludursə həmən növbəti indeksə baxırıq və ora boşdursə ora yerləşdirir yox əgər ora da doludursə bir növbətiyə 
baxırıq və s. Buradakı problem də odur ki , Boş indeksi tapmaq bizə vaxt itkisi olaraq geri qayıdacaqdır. Yenə də bu üsul
chaining dən daha əlverişli sayılır. 

Probbing strategiyası ilə əlaqəli önəmli detallardan biri odur ki , əlbətdə ki , bir müddətdən sonra arxadakı array tamami ilə dolacaqdır və
bizim onu böyütməyimiz gərəcəkdir. Bu zaman içaridə ola  bütün dəyərlrəin yeni yaradılacaq arrayən öıçüsünə uyğun hash
ları hesablanmalı və onlar yenidən hər biri kphnə arrayın içindən gıtürülərək yeniyə doldurulmalıdıdr. Və bu proses olduqca 
ləngdir.

Əməliyyatlar
put(key, value) => The best O(1), The worst O(N)
get(key) => The best O(1), The worst O(N)
set(key, value) => The best O(1), The worst O(N)
delete(key) => The best O(1), The worst O(N)










